"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const extensionizer_1 = __importDefault(require("extensionizer"));
const helpers_1 = require("./helpers");
const constants_1 = require("./constants");
class BackgroundController {
    constructor(config) {
        this.trustedSources = [];
        this.ports = new Map();
        this.controllers = new Map();
        const { controllers, trustedSources, } = config;
        this.name = config.name;
        if (typeof trustedSources === 'string') {
            this.trustedSources = [trustedSources];
        }
        else if (Array.isArray(trustedSources)) {
            this.trustedSources = trustedSources;
        }
        if (controllers) {
            for (const [name, controller] of Object.entries(controllers)) {
                this.controllers.set(name, controller);
            }
        }
        this.onTabRemoved = this.onTabRemoved.bind(this);
        this.onPortMessage = this.onPortMessage.bind(this);
        this.onConnectListener = this.onConnectListener.bind(this);
    }
    exposeController(name, controller) {
        this.controllers.set(name, controller);
    }
    removeController(name) {
        return this.controllers.delete(name);
    }
    callController(message, port) {
        var _a, _b, _c;
        const method = message.data.data.method;
        const controller = this.controllers.get(method);
        if (!controller) {
            console.error(`controller "${method}" does not exist`);
            const errMessage = {
                target: port.name,
                data: {
                    name: this.name,
                    data: {
                        id: message.data.data.id,
                        jsonrpc: '2.0',
                        error: {
                            code: constants_1.JSON_RPC_ERROR_CODES.METHOD_NOT_FOUND,
                            message: `Method ${message.data.data.method} does not exist`,
                        },
                    },
                },
            };
            port.postMessage(errMessage);
            return;
        }
        const tabId = ((_b = (_a = port.sender) === null || _a === void 0 ? void 0 : _a.tab) === null || _b === void 0 ? void 0 : _b.id) || 0;
        const frameId = ((_c = port.sender) === null || _c === void 0 ? void 0 : _c.frameId) || 0;
        const portId = `${tabId}:${frameId}`;
        controller({
            message,
            callback: this.sendPortResponse.bind(this, port, message.data.data.id),
            ports: this.ports,
            sender: {
                port,
                tabId,
                frameId,
                id: portId,
                name: port.name,
            },
        }, ...message.data.data.params);
    }
    sendPortResponse(port, callId, err, res, targetPorts) {
        if (!targetPorts) {
            const resMessage = this.buildResMessage(port.name, this.name, callId, err, res);
            port.postMessage(resMessage);
            return;
        }
        targetPorts.forEach((targetPort) => {
            const _port = this.ports.get(targetPort.portId);
            if (_port) {
                const resMessage = this.buildResMessage(_port.name, this.name, targetPort.callId, err, res);
                _port.postMessage(resMessage);
            }
        });
    }
    buildResMessage(target, name, id, err, res) {
        const resMessage = {
            target,
            data: {
                name,
                data: Object.assign({ id, jsonrpc: '2.0' }, (err ? { error: err } : { result: res })),
            },
        };
        return resMessage;
    }
    sendResponse(message) {
        const { targetPorts } = message, rpcResponse = __rest(message, ["targetPorts"]);
        let portsIds = [];
        if (typeof targetPorts === 'string') {
            portsIds = [targetPorts];
        }
        else if (Array.isArray(targetPorts)) {
            portsIds = targetPorts;
        }
        portsIds.forEach((portId) => {
            const port = this.ports.get(portId);
            if (port) {
                port.postMessage(rpcResponse);
            }
        });
    }
    onPortMessage(message, port) {
        const { type, isValid } = helpers_1.validateMessageSchema(message);
        if (!isValid) {
            console.error('port message not valid', message);
            return;
        }
        switch (type) {
            case 'req':
                this.callController(message, port);
                break;
            case 'res':
                this.sendResponse(message);
                break;
        }
    }
    onConnectListener(port) {
        var _a, _b, _c;
        if (!this.trustedSources.includes(port.name)) {
            console.error(`Port ${port.name} not allowed`);
            return;
        }
        ;
        this.updatePorts();
        const tabId = (_b = (_a = port.sender) === null || _a === void 0 ? void 0 : _a.tab) === null || _b === void 0 ? void 0 : _b.id;
        const frameId = ((_c = port.sender) === null || _c === void 0 ? void 0 : _c.frameId) || 0;
        if (tabId === undefined || tabId === null) {
            console.error('Port does not contain a valid tabId');
            return;
        }
        ;
        const portId = `${tabId}:${frameId}`;
        this.ports.set(portId, port);
        port.onMessage.addListener(this.onPortMessage);
    }
    onTabRemoved(tabId) {
        const regexp = new RegExp(`^${tabId}:`, 'i');
        this.ports.forEach((port, key) => {
            if (regexp.test(key)) {
                port.disconnect();
                this.ports.delete(key);
            }
        });
    }
    updatePorts() {
        extensionizer_1.default.tabs.query({}, (tabs) => {
            const tabsIds = tabs.map((tab) => tab.id);
            this.ports.forEach((port, key) => {
                const tabId = parseInt(key.split(':')[0], 10);
                if (!tabsIds.includes(tabId)) {
                    port.disconnect();
                    this.ports.delete(key);
                }
            });
        });
    }
    start() {
        extensionizer_1.default.runtime.onConnect.addListener(this.onConnectListener);
        extensionizer_1.default.tabs.onRemoved.addListener(this.onTabRemoved);
    }
    stop() {
        this.ports.forEach((port) => {
            port.disconnect();
        });
        this.ports.clear();
        extensionizer_1.default.runtime.onConnect.removeListener(this.onConnectListener);
        extensionizer_1.default.tabs.onRemoved.removeListener(this.onTabRemoved);
    }
}
exports.default = BackgroundController;
