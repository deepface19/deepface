var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
import extension from 'extensionizer';
import { validateMessageSchema } from './helpers';
import { JSON_RPC_ERROR_CODES } from './constants';
var BackgroundController = (function () {
    function BackgroundController(config) {
        this.trustedSources = [];
        this.ports = new Map();
        this.controllers = new Map();
        var controllers = config.controllers, trustedSources = config.trustedSources;
        this.name = config.name;
        if (typeof trustedSources === 'string') {
            this.trustedSources = [trustedSources];
        }
        else if (Array.isArray(trustedSources)) {
            this.trustedSources = trustedSources;
        }
        if (controllers) {
            for (var _i = 0, _a = Object.entries(controllers); _i < _a.length; _i++) {
                var _b = _a[_i], name_1 = _b[0], controller = _b[1];
                this.controllers.set(name_1, controller);
            }
        }
        this.onTabRemoved = this.onTabRemoved.bind(this);
        this.onPortMessage = this.onPortMessage.bind(this);
        this.onConnectListener = this.onConnectListener.bind(this);
    }
    BackgroundController.prototype.exposeController = function (name, controller) {
        this.controllers.set(name, controller);
    };
    BackgroundController.prototype.removeController = function (name) {
        return this.controllers.delete(name);
    };
    BackgroundController.prototype.callController = function (message, port) {
        var _a, _b, _c;
        var method = message.data.data.method;
        var controller = this.controllers.get(method);
        if (!controller) {
            console.error("controller \"" + method + "\" does not exist");
            var errMessage = {
                target: port.name,
                data: {
                    name: this.name,
                    data: {
                        id: message.data.data.id,
                        jsonrpc: '2.0',
                        error: {
                            code: JSON_RPC_ERROR_CODES.METHOD_NOT_FOUND,
                            message: "Method " + message.data.data.method + " does not exist",
                        },
                    },
                },
            };
            port.postMessage(errMessage);
            return;
        }
        var tabId = ((_b = (_a = port.sender) === null || _a === void 0 ? void 0 : _a.tab) === null || _b === void 0 ? void 0 : _b.id) || 0;
        var frameId = ((_c = port.sender) === null || _c === void 0 ? void 0 : _c.frameId) || 0;
        var portId = tabId + ":" + frameId;
        controller.apply(void 0, __spreadArray([{
                message: message,
                callback: this.sendPortResponse.bind(this, port, message.data.data.id),
                ports: this.ports,
                sender: {
                    port: port,
                    tabId: tabId,
                    frameId: frameId,
                    id: portId,
                    name: port.name,
                },
            }], message.data.data.params));
    };
    BackgroundController.prototype.sendPortResponse = function (port, callId, err, res, targetPorts) {
        var _this = this;
        if (!targetPorts) {
            var resMessage = this.buildResMessage(port.name, this.name, callId, err, res);
            port.postMessage(resMessage);
            return;
        }
        targetPorts.forEach(function (targetPort) {
            var _port = _this.ports.get(targetPort.portId);
            if (_port) {
                var resMessage = _this.buildResMessage(_port.name, _this.name, targetPort.callId, err, res);
                _port.postMessage(resMessage);
            }
        });
    };
    BackgroundController.prototype.buildResMessage = function (target, name, id, err, res) {
        var resMessage = {
            target: target,
            data: {
                name: name,
                data: __assign({ id: id, jsonrpc: '2.0' }, (err ? { error: err } : { result: res })),
            },
        };
        return resMessage;
    };
    BackgroundController.prototype.sendResponse = function (message) {
        var _this = this;
        var targetPorts = message.targetPorts, rpcResponse = __rest(message, ["targetPorts"]);
        var portsIds = [];
        if (typeof targetPorts === 'string') {
            portsIds = [targetPorts];
        }
        else if (Array.isArray(targetPorts)) {
            portsIds = targetPorts;
        }
        portsIds.forEach(function (portId) {
            var port = _this.ports.get(portId);
            if (port) {
                port.postMessage(rpcResponse);
            }
        });
    };
    BackgroundController.prototype.onPortMessage = function (message, port) {
        var _a = validateMessageSchema(message), type = _a.type, isValid = _a.isValid;
        if (!isValid) {
            console.error('port message not valid', message);
            return;
        }
        switch (type) {
            case 'req':
                this.callController(message, port);
                break;
            case 'res':
                this.sendResponse(message);
                break;
        }
    };
    BackgroundController.prototype.onConnectListener = function (port) {
        var _a, _b, _c;
        if (!this.trustedSources.includes(port.name)) {
            console.error("Port " + port.name + " not allowed");
            return;
        }
        ;
        this.updatePorts();
        var tabId = (_b = (_a = port.sender) === null || _a === void 0 ? void 0 : _a.tab) === null || _b === void 0 ? void 0 : _b.id;
        var frameId = ((_c = port.sender) === null || _c === void 0 ? void 0 : _c.frameId) || 0;
        if (tabId === undefined || tabId === null) {
            console.error('Port does not contain a valid tabId');
            return;
        }
        ;
        var portId = tabId + ":" + frameId;
        this.ports.set(portId, port);
        port.onMessage.addListener(this.onPortMessage);
    };
    BackgroundController.prototype.onTabRemoved = function (tabId) {
        var _this = this;
        var regexp = new RegExp("^" + tabId + ":", 'i');
        this.ports.forEach(function (port, key) {
            if (regexp.test(key)) {
                port.disconnect();
                _this.ports.delete(key);
            }
        });
    };
    BackgroundController.prototype.updatePorts = function () {
        var _this = this;
        extension.tabs.query({}, function (tabs) {
            var tabsIds = tabs.map(function (tab) { return tab.id; });
            _this.ports.forEach(function (port, key) {
                var tabId = parseInt(key.split(':')[0], 10);
                if (!tabsIds.includes(tabId)) {
                    port.disconnect();
                    _this.ports.delete(key);
                }
            });
        });
    };
    BackgroundController.prototype.start = function () {
        extension.runtime.onConnect.addListener(this.onConnectListener);
        extension.tabs.onRemoved.addListener(this.onTabRemoved);
    };
    BackgroundController.prototype.stop = function () {
        this.ports.forEach(function (port) {
            port.disconnect();
        });
        this.ports.clear();
        extension.runtime.onConnect.removeListener(this.onConnectListener);
        extension.tabs.onRemoved.removeListener(this.onTabRemoved);
    };
    return BackgroundController;
}());
export default BackgroundController;
