"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const uuid_1 = require("uuid");
const helpers_1 = require("./helpers");
const constants_1 = require("./constants");
class RPC {
    constructor(config) {
        this.timeout = 5000;
        this.handlers = new Map();
        this.calls = new Map();
        this.name = config.name;
        this.target = config.target;
        if (config.timeout) {
            this.timeout = config.timeout;
        }
        if (config.handlers) {
            for (const [name, handler] of Object.entries(config.handlers)) {
                this.handlers.set(name, handler);
            }
        }
    }
    ;
    exposeHandler(name, handler) {
        this.handlers.set(name, handler);
    }
    removeHandler(name) {
        return this.handlers.delete(name);
    }
    _call(handler, target, timeout, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const id = uuid_1.v4();
            const message = {
                target: target,
                data: {
                    name: this.name,
                    data: {
                        id,
                        jsonrpc: constants_1.JSON_RPC_VERSION,
                        method: handler,
                        params: args,
                    },
                },
            };
            return new Promise((resolve, reject) => {
                const resolver = (err, res) => {
                    if (err) {
                        reject(new Error(err.message));
                        return;
                    }
                    resolve(res);
                };
                let timer;
                if (timeout > 0) {
                    timer = setTimeout(() => {
                        if (this.calls.has(id)) {
                            this.calls.delete(id);
                            resolver({
                                code: constants_1.JSON_RPC_ERROR_CODES.TIMEOUT_ERROR,
                                message: 'Request Timeout',
                            });
                        }
                    }, timeout);
                }
                ;
                this.calls.set(id, { resolver, timer });
                this.sendMessage(message);
            });
        });
    }
    call(handler, args, config) {
        return __awaiter(this, void 0, void 0, function* () {
            let timeout = this.timeout;
            if (config && typeof config.timeout === 'number') {
                timeout = config.timeout;
            }
            return this._call(handler, (config === null || config === void 0 ? void 0 : config.target) || this.target, timeout, args || []);
        });
    }
    onMessage(eventMessage) {
        const { type, isValid } = helpers_1.validateMessageSchema(eventMessage);
        if (!isValid)
            return;
        const message = eventMessage;
        if (message.target === this.name && this.target === message.data.name) {
            switch (type) {
                case 'req':
                    this.onRequestMessage(message);
                    break;
                case 'res':
                    this.onResponseMessage(message);
                    break;
            }
        }
    }
    onRequestMessage(message) {
        const resMessage = {
            target: this.target,
            data: {
                name: this.name,
                data: {
                    id: message.data.data.id,
                    jsonrpc: constants_1.JSON_RPC_VERSION,
                },
            },
        };
        try {
            const handler = this.handlers.get(message.data.data.method);
            if (!handler) {
                resMessage.data.data.error = {
                    code: constants_1.JSON_RPC_ERROR_CODES.METHOD_NOT_FOUND,
                    message: `Method ${message.data.data.method} does not exist`,
                };
                this.sendMessage(resMessage);
                return;
            }
            const callback = (err, res) => {
                if (err) {
                    resMessage.data.data.error = err;
                    this.sendMessage(resMessage);
                    return;
                }
                resMessage.data.data.result = res;
                this.sendMessage(resMessage);
            };
            handler({
                callback,
                message,
            }, ...message.data.data.params);
        }
        catch (error) {
            if (resMessage.data.data.hasOwnProperty('error'))
                return;
            if (resMessage.data.data.hasOwnProperty('result'))
                return;
            resMessage.data.data.error = {
                code: constants_1.JSON_RPC_ERROR_CODES.SERVER_ERROR,
                message: error.toString(),
            };
            this.sendMessage(resMessage);
        }
        ;
    }
    onResponseMessage(message) {
        const { id, error, result } = message.data.data;
        const call = this.calls.get(id);
        if (!call)
            return;
        if (call.timer) {
            clearTimeout(call.timer);
        }
        call.resolver(error, result);
        this.calls.delete(id);
    }
    stop() {
        this.calls.forEach((call) => {
            if (call.timer) {
                clearTimeout(call.timer);
            }
            call.resolver({
                message: 'RPC stopped',
                code: constants_1.JSON_RPC_ERROR_CODES.INTERNAL_ERROR,
            });
        });
        this.calls.clear();
    }
}
exports.default = RPC;
;
